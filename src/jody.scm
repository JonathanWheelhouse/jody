(define state 'attack)
(define target_x 0)
(define target_y 0)

(define (play_computer)
  (if (eqv? state 'attack)
      (attack)
      (evade))
  (let ((arc (- (angle_to_player) (computer_angle))))
    (if (< arc 0) (set! arc (+ 360 arc)))
    (let ((angle 0))
      (if (< arc 180)
	  (set! angle (+ (computer_angle) 3))
	  (set! angle (- (computer_angle) 3)))
      (set_computer_angle angle))))

(define (attack)
  (set! target_x (player_x))
  (set! target_y (player_y))
  (cond ((< (dist_to_player) 30) (set! state 'evade) (set! target_x -1))
	(else (cond ((> (dist_to_player) 100) (set_computer_accel (player_forward_thrust)))
		    ((> (dist_to_player) 50) (set_computer_accel (/ (player_forward_thrust) 3)))
		    (else (set_computer_accel 0)))
	      (if (< (dist_to_player) 200) (fire_weapon)))))


(define (evade)
  (cond ((and (< (abs (- target_x (computer_x))) 10) (< (abs (- target_y (computer_y))) 10))
	 (display "Going back into ATTACK mode.\n")
	 (set! state 'attack))
	(else (cond ((< target_x 0)
		     (set! target_x (random (world_width)))
		     (set! target_y (random (world_height)))
		     (display "Selected new EVADE target.\n"))
		    (set_computer_accel (player_forward_thrust))))))

(define (dist_to_player)
  (let ((xdiff (- (computer_x) (player_x)))
	(ydiff (- (computer_y) (player_y))))
    (sqrt (+ (* xdiff xdiff) (* ydiff ydiff)))))

(define (angle_to_player)
  (let* ((xdiff (- target_x (computer_x)))
	 (ydiff (- target_y (computer_y)))
	 (theta (scm_atan2 (- 0 ydiff) xdiff)))
    (if (< theta 0) (set! theta (+ (* 2 3.141592654) theta)))
    (* theta (/ 180 3.141592654))))
